use anyhow::Result;
use sqlx::{Row, SqlitePool};

#[derive(Debug, Clone)]
pub struct Database {
    pub pool: SqlitePool,
}

impl Database {
    pub async fn new(database_url: &str) -> Result<Self> {
        let pool = SqlitePool::connect(database_url).await?;
        Ok(Self { pool })
    }

    pub async fn migrate(&self) -> Result<()> {
        tracing::info!("üîÑ ÂºÄÂßãÊï∞ÊçÆÂ∫ìËøÅÁßª");

        // ÂàõÂª∫Áî®Êà∑Ë°®
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE,
                hashed_password TEXT NOT NULL,
                role TEXT NOT NULL CHECK (role IN ('platform_admin', 'project_manager', 'task_executor')),
                is_active BOOLEAN DEFAULT TRUE,
                is_verified BOOLEAN DEFAULT FALSE,
                parent_id INTEGER,
                full_name TEXT,
                phone TEXT,
                company TEXT,
                max_employees INTEGER DEFAULT 10,
                current_employees INTEGER DEFAULT 0,
                balance REAL DEFAULT 1000.0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_login DATETIME,
                company_id INTEGER
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Âà†Èô§ÊóßÁöÑÂ∑•‰ΩúËÆ∞ÂΩïË°®ÔºàÂ¶ÇÊûúÂ≠òÂú®ÔºâÂπ∂ÈáçÊñ∞ÂàõÂª∫
        sqlx::query("DROP TABLE IF EXISTS work_records")
            .execute(&self.pool)
            .await?;

        // ÂàõÂª∫Â∑•‰ΩúËÆ∞ÂΩïË°®ÔºàÂåπÈÖçWorkRecordÊ®°ÂûãÔºâ
        sqlx::query(
            r#"
            CREATE TABLE work_records (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                device_id TEXT NOT NULL,
                platform TEXT NOT NULL,
                action_type TEXT NOT NULL,
                target_count INTEGER NOT NULL DEFAULT 0,
                completed_count INTEGER NOT NULL DEFAULT 0,
                status TEXT NOT NULL DEFAULT 'pending',
                created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // ÂàõÂª∫ËÆæÂ§áË°®
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS devices (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                device_name TEXT NOT NULL,
                device_type TEXT NOT NULL,
                adb_id TEXT,
                status TEXT NOT NULL DEFAULT 'offline',
                last_seen DATETIME,
                created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Âà†Èô§ÊóßÁöÑËÆ°Ë¥πËÆ∞ÂΩïË°®ÔºàÂ¶ÇÊûúÂ≠òÂú®ÔºâÂπ∂ÈáçÊñ∞ÂàõÂª∫
        sqlx::query("DROP TABLE IF EXISTS billing_records")
            .execute(&self.pool)
            .await?;

        // ÂàõÂª∫ËÆ°Ë¥πËÆ∞ÂΩïË°®
        sqlx::query(
            r#"
            CREATE TABLE billing_records (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                amount REAL NOT NULL,
                billing_type TEXT NOT NULL,
                description TEXT,
                created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Âà†Èô§ÊóßÁöÑ‰ª∑Ê†ºËßÑÂàôË°®ÔºàÂ¶ÇÊûúÂ≠òÂú®ÔºâÂπ∂ÈáçÊñ∞ÂàõÂª∫
        sqlx::query("DROP TABLE IF EXISTS pricing_rules")
            .execute(&self.pool)
            .await?;

        // ÂàõÂª∫‰ª∑Ê†ºËßÑÂàôË°®
        sqlx::query(
            r#"
            CREATE TABLE pricing_rules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                rule_name TEXT NOT NULL,
                billing_type TEXT NOT NULL,
                unit_price REAL NOT NULL,
                is_active BOOLEAN DEFAULT TRUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // ÂàõÂª∫ÂÖ¨Âè∏Ë°®
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS companies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                code TEXT UNIQUE NOT NULL,
                description TEXT,
                contact_email TEXT,
                contact_phone TEXT,
                max_employees INTEGER DEFAULT 10,
                is_active BOOLEAN DEFAULT TRUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // ÂàõÂª∫ÂÖ¨Âè∏Êî∂Ë¥πËÆ°ÂàíË°®
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS company_pricing_plans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                company_name TEXT NOT NULL UNIQUE,
                plan_name TEXT NOT NULL,
                employee_monthly_fee REAL NOT NULL DEFAULT 50.0,
                is_active BOOLEAN DEFAULT TRUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // ÂàõÂª∫ÂÖ¨Âè∏Êìç‰ΩúÊî∂Ë¥πËßÑÂàôË°®
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS company_operation_pricing (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                company_name TEXT NOT NULL,
                platform TEXT NOT NULL,
                operation_type TEXT NOT NULL,
                unit_price REAL NOT NULL,
                is_active BOOLEAN DEFAULT TRUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(company_name, platform, operation_type)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // ÂàõÂª∫Á≥ªÁªüÈÖçÁΩÆË°®
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS system_settings (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                description TEXT,
                updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // ÊèíÂÖ•ÈªòËÆ§Á≥ªÁªüÁÆ°ÁêÜÂëò(Â¶ÇÊûú‰∏çÂ≠òÂú®)
        let admin_exists =
            sqlx::query("SELECT COUNT(*) as count FROM users WHERE role = 'platform_admin'")
                .fetch_one(&self.pool)
                .await?
                .get::<i64, _>("count")
                > 0;

        if !admin_exists {
            let password_hash = bcrypt::hash("admin123", 12)?;

            sqlx::query(
                r#"
                INSERT INTO users (username, email, hashed_password, role, is_active)
                VALUES (?, ?, ?, ?, ?)
                "#,
            )
            .bind("admin")
            .bind("admin@flowfarm.com")
            .bind(&password_hash)
            .bind("platform_admin")
            .bind(true)
            .execute(&self.pool)
            .await?;

            tracing::info!("‚úÖ ÈªòËÆ§ÁÆ°ÁêÜÂëòË¥¶Êà∑Â∑≤ÂàõÂª∫ - Áî®Êà∑Âêç: admin, ÂØÜÁ†Å: admin123");
        }

        // ÂàõÂª∫ÊµãËØïÁî®Êà∑Ôºà‰ªÖÂú®ÂºÄÂèëÁéØÂ¢ÉÔºâ
        self.create_test_users().await?;

        // ÂàõÂª∫ÊµãËØïÂÖ¨Âè∏Êï∞ÊçÆ
        self.create_test_companies().await?;

        // ÂàõÂª∫ÊµãËØï‰ª∑Ê†ºËßÑÂàô
        self.create_test_pricing_rules().await?;

        // ÂàõÂª∫ÊµãËØïÂÖ¨Âè∏Êî∂Ë¥πËÆ°Âàí
        self.create_test_company_pricing().await?;

        // ÂàõÂª∫ÊµãËØïÈ°πÁõÆÂíå‰ªªÂä°Êï∞ÊçÆ
        self.create_test_projects_and_tasks().await?;

        tracing::info!("‚úÖ Êï∞ÊçÆÂ∫ìËøÅÁßªÂÆåÊàê");
        Ok(())
    }

    async fn create_test_pricing_rules(&self) -> Result<()> {
        tracing::info!("üîÑ ÂàõÂª∫ÊµãËØï‰ª∑Ê†ºËßÑÂàôÊï∞ÊçÆ");

        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®‰ª∑Ê†ºËßÑÂàô
        let rules_count = sqlx::query("SELECT COUNT(*) as count FROM pricing_rules")
            .fetch_one(&self.pool)
            .await?
            .get::<i64, _>("count");

        if rules_count == 0 {
            // ÂàõÂª∫ÈªòËÆ§‰ª∑Ê†ºËßÑÂàô
            let rules = vec![
                ("ÊäñÈü≥ÂÖ≥Ê≥®", "douyin_follow", 0.05),
                ("ÊäñÈü≥ÁÇπËµû", "douyin_like", 0.02),
                ("Â∞èÁ∫¢‰π¶ÂÖ≥Ê≥®", "xiaohongshu_follow", 0.08),
                ("Â∞èÁ∫¢‰π¶ÁÇπËµû", "xiaohongshu_like", 0.03),
                ("Â∞èÁ∫¢‰π¶Êî∂Ëóè", "xiaohongshu_favorite", 0.04),
            ];

            for (rule_name, billing_type, unit_price) in rules {
                sqlx::query(
                    r#"
                    INSERT INTO pricing_rules (rule_name, billing_type, unit_price, is_active)
                    VALUES (?, ?, ?, ?)
                    "#,
                )
                .bind(rule_name)
                .bind(billing_type)
                .bind(unit_price)
                .bind(true)
                .execute(&self.pool)
                .await?;
            }

            tracing::info!("‚úÖ ÊµãËØï‰ª∑Ê†ºËßÑÂàôÂàõÂª∫ÂÆåÊàê");
        } else {
            tracing::info!("‚ÑπÔ∏è  ‰ª∑Ê†ºËßÑÂàôÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫");
        }

        Ok(())
    }

    async fn create_test_users(&self) -> Result<()> {
        tracing::info!("üîÑ ÂàõÂª∫ÊµãËØïÁî®Êà∑Êï∞ÊçÆ");

        let password_hash = bcrypt::hash("admin123", 12)?;

        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®company_admin_1Áî®Êà∑
        let company_admin_exists =
            sqlx::query("SELECT COUNT(*) as count FROM users WHERE username = 'company_admin_1'")
                .fetch_one(&self.pool)
                .await?
                .get::<i64, _>("count")
                > 0;

        if !company_admin_exists {
            // ÂàõÂª∫ÂÖ¨Âè∏ÁÆ°ÁêÜÂëò1
            sqlx::query(
                r#"
                INSERT INTO users (username, email, hashed_password, role, company, is_active, max_employees)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                "#,
            )
            .bind("company_admin_1")
            .bind("company_admin_1@example.com")
            .bind(&password_hash)
            .bind("project_manager")
            .bind("company_001")
            .bind(true)
            .bind(50)
            .execute(&self.pool)
            .await?;

            // ÂàõÂª∫ÂÖ¨Âè∏ÁÆ°ÁêÜÂëò2
            sqlx::query(
                r#"
                INSERT INTO users (username, email, hashed_password, role, company, is_active, max_employees)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                "#,
            )
            .bind("company_admin_2")
            .bind("company_admin_2@example.com")
            .bind(&password_hash)
            .bind("project_manager")
            .bind("company_002")
            .bind(true)
            .bind(30)
            .execute(&self.pool)
            .await?;

            // ÂàõÂª∫ÊµãËØïÂëòÂ∑•
            let employees = vec![
                ("employee_1", "employee_1@company_001.com", "company_001"),
                ("employee_2", "employee_2@company_001.com", "company_001"),
                ("employee_3", "employee_3@company_002.com", "company_002"),
            ];

            for (username, email, company) in employees {
                sqlx::query(
                    r#"
                    INSERT INTO users (username, email, hashed_password, role, company, is_active)
                    VALUES (?, ?, ?, ?, ?, ?)
                    "#,
                )
                .bind(username)
                .bind(email)
                .bind(&password_hash)
                .bind("task_executor")
                .bind(company)
                .bind(true)
                .execute(&self.pool)
                .await?;
            }

            tracing::info!("‚úÖ ÊµãËØïÁî®Êà∑ÂàõÂª∫ÂÆåÊàê");
            tracing::info!("   - company_admin_1 (ÂØÜÁ†Å: admin123)");
            tracing::info!("   - company_admin_2 (ÂØÜÁ†Å: admin123)");
            tracing::info!("   - employee_1, employee_2, employee_3 (ÂØÜÁ†Å: admin123)");
        } else {
            tracing::info!("‚ÑπÔ∏è  ÊµãËØïÁî®Êà∑Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫");
        }

        Ok(())
    }

    async fn create_test_companies(&self) -> Result<()> {
        tracing::info!("üîÑ ÂàõÂª∫ÊµãËØïÂÖ¨Âè∏Êï∞ÊçÆ");

        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂÖ¨Âè∏Êï∞ÊçÆ
        let companies_count = sqlx::query("SELECT COUNT(*) as count FROM companies")
            .fetch_one(&self.pool)
            .await?
            .get::<i64, _>("count");

        if companies_count == 0 {
            // ÂàõÂª∫ÈªòËÆ§ÊµãËØïÂÖ¨Âè∏
            let companies = vec![
                ("ÊµãËØïÂÖ¨Âè∏A", "company_001", "ËøôÊòØÊµãËØïÂÖ¨Âè∏A", "companyA@example.com", "13800000001", 20),
                ("ÊµãËØïÂÖ¨Âè∏B", "company_002", "ËøôÊòØÊµãËØïÂÖ¨Âè∏B", "companyB@example.com", "13800000002", 15),
            ];

            for (name, code, description, email, phone, max_employees) in companies {
                sqlx::query(
                    r#"
                    INSERT INTO companies (name, code, description, contact_email, contact_phone, max_employees, is_active)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                    "#,
                )
                .bind(name)
                .bind(code)
                .bind(description)
                .bind(email)
                .bind(phone)
                .bind(max_employees)
                .bind(true)
                .execute(&self.pool)
                .await?;
            }

            tracing::info!("‚úÖ ÊµãËØïÂÖ¨Âè∏Êï∞ÊçÆÂàõÂª∫ÂÆåÊàê");
        } else {
            tracing::info!("‚ÑπÔ∏è  ÂÖ¨Âè∏Êï∞ÊçÆÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫");
        }

        Ok(())
    }

    async fn create_test_company_pricing(&self) -> Result<()> {
        tracing::info!("üîÑ ÂàõÂª∫ÊµãËØïÂÖ¨Âè∏Êî∂Ë¥πËÆ°Âàí");

        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂÖ¨Âè∏Êî∂Ë¥πËÆ°Âàí
        let plans_count = sqlx::query("SELECT COUNT(*) as count FROM company_pricing_plans")
            .fetch_one(&self.pool)
            .await?
            .get::<i64, _>("count");

        if plans_count == 0 {
            // ÂàõÂª∫ÈªòËÆ§ÂÖ¨Âè∏Êî∂Ë¥πËÆ°Âàí
            let plans = vec![
                ("company_001", "Ê†áÂáÜËÆ°Âàí", 50.0),
                ("company_002", "È´òÁ∫ßËÆ°Âàí", 80.0),
            ];

            for (company_name, plan_name, monthly_fee) in plans {
                sqlx::query(
                    r#"
                    INSERT INTO company_pricing_plans (company_name, plan_name, employee_monthly_fee, is_active)
                    VALUES (?, ?, ?, ?)
                    "#,
                )
                .bind(company_name)
                .bind(plan_name)
                .bind(monthly_fee)
                .bind(true)
                .execute(&self.pool)
                .await?;
            }

            // ÂàõÂª∫ÈªòËÆ§ÂÖ¨Âè∏Êìç‰ΩúÊî∂Ë¥πËßÑÂàô
            let operation_pricing = vec![
                // company_001 ÁöÑÊî∂Ë¥πÊ†áÂáÜ
                ("company_001", "xiaohongshu", "follow", 0.08),
                ("company_001", "xiaohongshu", "like", 0.03),
                ("company_001", "xiaohongshu", "favorite", 0.04),
                ("company_001", "douyin", "follow", 0.05),
                ("company_001", "douyin", "like", 0.02),
                // company_002 ÁöÑÊî∂Ë¥πÊ†áÂáÜ (È´òÁ∫ßËÆ°ÂàíÔºå‰ª∑Ê†ºÊõ¥‰Ωé)
                ("company_002", "xiaohongshu", "follow", 0.06),
                ("company_002", "xiaohongshu", "like", 0.02),
                ("company_002", "xiaohongshu", "favorite", 0.03),
                ("company_002", "douyin", "follow", 0.04),
                ("company_002", "douyin", "like", 0.015),
            ];

            for (company_name, platform, operation_type, unit_price) in operation_pricing {
                sqlx::query(
                    r#"
                    INSERT INTO company_operation_pricing (company_name, platform, operation_type, unit_price, is_active)
                    VALUES (?, ?, ?, ?, ?)
                    "#,
                )
                .bind(company_name)
                .bind(platform)
                .bind(operation_type)
                .bind(unit_price)
                .bind(true)
                .execute(&self.pool)
                .await?;
            }

            tracing::info!("‚úÖ ÊµãËØïÂÖ¨Âè∏Êî∂Ë¥πËÆ°ÂàíÂàõÂª∫ÂÆåÊàê");
        } else {
            tracing::info!("‚ÑπÔ∏è  ÂÖ¨Âè∏Êî∂Ë¥πËÆ°ÂàíÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫");
        }

        Ok(())
    }

    async fn create_test_projects_and_tasks(&self) -> Result<()> {
        tracing::info!("üîÑ ÂàõÂª∫ÊµãËØïÈ°πÁõÆÂíå‰ªªÂä°Êï∞ÊçÆ");

        // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®È°πÁõÆÊï∞ÊçÆ
        let projects_count = sqlx::query("SELECT COUNT(*) as count FROM projects")
            .fetch_one(&self.pool)
            .await?
            .get::<i64, _>("count");

        if projects_count == 0 {
            // Ëé∑ÂèñÁî®Êà∑ID
            let admin_id = sqlx::query("SELECT id FROM users WHERE username = 'admin'")
                .fetch_one(&self.pool)
                .await?
                .get::<i64, _>("id");

            let company_admin_1_id = sqlx::query("SELECT id FROM users WHERE username = 'company_admin_1'")
                .fetch_one(&self.pool)
                .await?
                .get::<i64, _>("id");

            let employee_1_id = sqlx::query("SELECT id FROM users WHERE username = 'employee_1'")
                .fetch_one(&self.pool)
                .await?
                .get::<i64, _>("id");

            let employee_2_id = sqlx::query("SELECT id FROM users WHERE username = 'employee_2'")
                .fetch_one(&self.pool)
                .await?
                .get::<i64, _>("id");

            // ÂàõÂª∫È°πÁõÆÔºà‰ΩøÁî® UUID ‰Ωú‰∏∫ IDÔºâ
            use uuid::Uuid;
            
            let projects = vec![
                (
                    Uuid::new_v4().to_string(),
                    "TaskFleet Á≥ªÁªüÂºÄÂèë",
                    "ÂºÄÂèë TaskFleet ‰ªªÂä°ÁÆ°ÁêÜÁ≥ªÁªüÁöÑÊ†∏ÂøÉÂäüËÉΩÊ®°Âùó",
                    admin_id.to_string(),
                    "in_progress",
                    "2025-10-01",
                    "2025-12-31",
                ),
                (
                    Uuid::new_v4().to_string(),
                    "ÁîµÂïÜÂπ≥Âè∞Êé®ÂπøÈ°πÁõÆ",
                    "‰∏∫ÂÆ¢Êà∑ÁöÑÁîµÂïÜÂπ≥Âè∞ËøõË°åÂ§öÊ∏†ÈÅìÁ§æ‰∫§Â™í‰ΩìÊé®Âπø",
                    company_admin_1_id.to_string(),
                    "in_progress",
                    "2025-10-15",
                    "2025-11-30",
                ),
                (
                    Uuid::new_v4().to_string(),
                    "ÂìÅÁâåËê•ÈîÄÊ¥ªÂä®",
                    "Á≠ñÂàíÂπ∂ÊâßË°åÂìÅÁâåÂú®Â∞èÁ∫¢‰π¶ÂíåÊäñÈü≥ÁöÑËê•ÈîÄÊ¥ªÂä®",
                    company_admin_1_id.to_string(),
                    "planning",
                    "2025-11-01",
                    "2025-12-15",
                ),
            ];

            let mut project_ids = Vec::new();
            for (id, name, description, owner_id, status, start_date, end_date) in projects {
                sqlx::query(
                    r#"
                    INSERT INTO projects (id, name, description, owner_id, status, start_date, end_date, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                    "#,
                )
                .bind(&id)
                .bind(name)
                .bind(description)
                .bind(&owner_id)
                .bind(status)
                .bind(start_date)
                .bind(end_date)
                .execute(&self.pool)
                .await?;
                
                project_ids.push((id, owner_id));
            }

            tracing::info!("‚úÖ ÊµãËØïÈ°πÁõÆÂàõÂª∫ÂÆåÊàêÔºåÂÖ± {} ‰∏™È°πÁõÆ", project_ids.len());

            // ÂàõÂª∫‰ªªÂä°
            let tasks = vec![
                // È°πÁõÆ1 (TaskFleetÁ≥ªÁªüÂºÄÂèë) - adminÂàõÂª∫ÁöÑ‰ªªÂä°
                (
                    Uuid::new_v4().to_string(),
                    "ËÆæËÆ°Êï∞ÊçÆÂ∫ìÊû∂ÊûÑ",
                    "ËÆæËÆ°Áî®Êà∑„ÄÅÈ°πÁõÆ„ÄÅ‰ªªÂä°„ÄÅÂ∑•‰ΩúÊó•ÂøóÁ≠âÊ†∏ÂøÉË°®ÁªìÊûÑ",
                    "completed",
                    "high",
                    project_ids[0].0.clone(),
                    Some(admin_id.to_string()),
                    admin_id.to_string(),
                    Some("2025-10-05"),
                    Some(16.0),
                    Some(15.5),
                    Some("2025-10-05 18:00:00"),
                ),
                (
                    Uuid::new_v4().to_string(),
                    "ÂÆûÁé∞Áî®Êà∑ËÆ§ËØÅÁ≥ªÁªü",
                    "ÂºÄÂèëJWTËÆ§ËØÅ„ÄÅËßíËâ≤ÊùÉÈôêÊéßÂà∂Á≠âÂäüËÉΩ",
                    "completed",
                    "high",
                    project_ids[0].0.clone(),
                    Some(admin_id.to_string()),
                    admin_id.to_string(),
                    Some("2025-10-10"),
                    Some(24.0),
                    Some(26.0),
                    Some("2025-10-11 20:00:00"),
                ),
                (
                    Uuid::new_v4().to_string(),
                    "ÂºÄÂèëÂâçÁ´ØÁïåÈù¢",
                    "‰ΩøÁî® React + TypeScript ÂºÄÂèëÂâçÁ´ØÁÆ°ÁêÜÁïåÈù¢",
                    "in_progress",
                    "high",
                    project_ids[0].0.clone(),
                    Some(admin_id.to_string()),
                    admin_id.to_string(),
                    Some("2025-10-25"),
                    Some(40.0),
                    Some(18.0),
                    None,
                ),
                
                // È°πÁõÆ2 (ÁîµÂïÜÂπ≥Âè∞Êé®Âπø) - company_admin_1ÂàõÂª∫Âπ∂ÂàÜÈÖçÁªôÂëòÂ∑•
                (
                    Uuid::new_v4().to_string(),
                    "Â∞èÁ∫¢‰π¶Ë¥¶Âè∑Á≤â‰∏ùÂ¢ûÈïø",
                    "ÈÄöËøá‰∫íÂä®ÂíåÂÜÖÂÆπÊé®ÂπøÔºåÁõÆÊ†áÂ¢ûÈïø5000Á≤â‰∏ù",
                    "in_progress",
                    "high",
                    project_ids[1].0.clone(),
                    Some(employee_1_id.to_string()),
                    company_admin_1_id.to_string(),
                    Some("2025-10-20"),
                    Some(30.0),
                    Some(12.0),
                    None,
                ),
                (
                    Uuid::new_v4().to_string(),
                    "ÊäñÈü≥Áõ¥Êí≠Èó¥ÂºïÊµÅ",
                    "‰∏∫ÁîµÂïÜÁõ¥Êí≠Èó¥ÂºïÊµÅÔºåÁõÆÊ†á1000‰∫∫Ê¨°Âú®Á∫øËßÇÁúã",
                    "pending",
                    "medium",
                    project_ids[1].0.clone(),
                    Some(employee_2_id.to_string()),
                    company_admin_1_id.to_string(),
                    Some("2025-10-22"),
                    Some(20.0),
                    None,
                    None,
                ),
                (
                    Uuid::new_v4().to_string(),
                    "‰∫ßÂìÅÁ¨îËÆ∞Âàõ‰Ωú",
                    "Êí∞ÂÜôÂπ∂ÂèëÂ∏É10ÁØáÈ´òË¥®Èáè‰∫ßÂìÅÊµãËØÑÁ¨îËÆ∞",
                    "in_progress",
                    "medium",
                    project_ids[1].0.clone(),
                    Some(employee_1_id.to_string()),
                    company_admin_1_id.to_string(),
                    Some("2025-10-25"),
                    Some(15.0),
                    Some(6.0),
                    None,
                ),
                
                // È°πÁõÆ3 (ÂìÅÁâåËê•ÈîÄÊ¥ªÂä®) - company_admin_1ÂàõÂª∫ÁöÑËÆ°Âàí‰∏≠‰ªªÂä°
                (
                    Uuid::new_v4().to_string(),
                    "Â∏ÇÂú∫Ë∞ÉÁ†îÂàÜÊûê",
                    "ÂàÜÊûêÁõÆÊ†áÁî®Êà∑Áæ§‰ΩìÂíåÁ´ûÂìÅÁ≠ñÁï•",
                    "pending",
                    "high",
                    project_ids[2].0.clone(),
                    Some(employee_1_id.to_string()),
                    company_admin_1_id.to_string(),
                    Some("2025-11-05"),
                    Some(16.0),
                    None,
                    None,
                ),
                (
                    Uuid::new_v4().to_string(),
                    "ÂÜÖÂÆπÂàõÊÑèÁ≠ñÂàí",
                    "Á≠ñÂàí30Â§©ÁöÑÂÜÖÂÆπÂèëÂ∏ÉËÆ°ÂàíÂíåÂàõÊÑèÊñπÊ°à",
                    "pending",
                    "medium",
                    project_ids[2].0.clone(),
                    Some(company_admin_1_id.to_string()),
                    company_admin_1_id.to_string(),
                    Some("2025-11-08"),
                    Some(24.0),
                    None,
                    None,
                ),
                
                // employee_1 Ëá™Â∑±ÂàõÂª∫ÁöÑ‰ªªÂä°Ôºà‰∏çÂÖ≥ËÅîÈ°πÁõÆÔºâ
                (
                    Uuid::new_v4().to_string(),
                    "Â≠¶‰π†Êñ∞ÁöÑÊé®ÂπøÊäÄÂ∑ß",
                    "ËßÇÁúãÂπ∂Â≠¶‰π†ÊúÄÊñ∞ÁöÑÁ§æ‰∫§Â™í‰ΩìËê•ÈîÄËØæÁ®ã",
                    "in_progress",
                    "low",
                    "".to_string(), // Êó†È°πÁõÆÂÖ≥ËÅî
                    Some(employee_1_id.to_string()),
                    employee_1_id.to_string(),
                    Some("2025-10-30"),
                    Some(8.0),
                    Some(3.0),
                    None,
                ),
                (
                    Uuid::new_v4().to_string(),
                    "Êï¥ÁêÜÂ∑•‰ΩúÊä•Âëä",
                    "Êï¥ÁêÜÊú¨Âë®ÁöÑÂ∑•‰ΩúÊàêÊûúÂíåÊï∞ÊçÆÊä•Âëä",
                    "pending",
                    "low",
                    "".to_string(),
                    Some(employee_1_id.to_string()),
                    employee_1_id.to_string(),
                    Some("2025-10-31"),
                    Some(4.0),
                    None,
                    None,
                ),
            ];

            let mut task_ids = Vec::new();
            for (id, title, description, status, priority, project_id, assigned_to, created_by, due_date, estimated_hours, actual_hours, completed_at) in tasks {
                let project_id_value = if project_id.is_empty() { None } else { Some(project_id) };
                
                sqlx::query(
                    r#"
                    INSERT INTO tasks (id, title, description, status, priority, project_id, assigned_to, created_by, due_date, estimated_hours, actual_hours, completed_at, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                    "#,
                )
                .bind(&id)
                .bind(title)
                .bind(description)
                .bind(status)
                .bind(priority)
                .bind(project_id_value)
                .bind(assigned_to)
                .bind(created_by)
                .bind(due_date)
                .bind(estimated_hours)
                .bind(actual_hours)
                .bind(completed_at)
                .execute(&self.pool)
                .await?;
                
                task_ids.push(id);
            }

            tracing::info!("‚úÖ ÊµãËØï‰ªªÂä°ÂàõÂª∫ÂÆåÊàêÔºåÂÖ± {} ‰∏™‰ªªÂä°", task_ids.len());

            // ÂàõÂª∫Â∑•‰ΩúÊó•Âøó
            let work_logs = vec![
                // admin ÁöÑÂ∑•‰ΩúÊó•Âøó
                (
                    Uuid::new_v4().to_string(),
                    task_ids[0].clone(), // ËÆæËÆ°Êï∞ÊçÆÂ∫ìÊû∂ÊûÑ
                    admin_id.to_string(),
                    "ÂÆåÊàê‰∫ÜÁî®Êà∑Ë°®ÂíåÊùÉÈôêË°®ÁöÑËÆæËÆ°",
                    8.0,
                    "2025-10-04",
                ),
                (
                    Uuid::new_v4().to_string(),
                    task_ids[0].clone(),
                    admin_id.to_string(),
                    "ÂÆåÊàê‰∫ÜÈ°πÁõÆÂíå‰ªªÂä°Ë°®ÁöÑËÆæËÆ°ÂèäÂÖ≥Á≥ªÂÆö‰πâ",
                    7.5,
                    "2025-10-05",
                ),
                (
                    Uuid::new_v4().to_string(),
                    task_ids[1].clone(), // Áî®Êà∑ËÆ§ËØÅÁ≥ªÁªü
                    admin_id.to_string(),
                    "ÂÆûÁé∞‰∫ÜJWT tokenÁîüÊàêÂíåÈ™åËØÅÈÄªËæë",
                    10.0,
                    "2025-10-09",
                ),
                (
                    Uuid::new_v4().to_string(),
                    task_ids[2].clone(), // ÂâçÁ´ØÁïåÈù¢
                    admin_id.to_string(),
                    "Êê≠Âª∫‰∫ÜReactÈ°πÁõÆÊ°ÜÊû∂ÔºåÈÖçÁΩÆ‰∫ÜË∑ØÁî±ÂíåÁä∂ÊÄÅÁÆ°ÁêÜ",
                    9.0,
                    "2025-10-20",
                ),
                
                // employee_1 ÁöÑÂ∑•‰ΩúÊó•Âøó
                (
                    Uuid::new_v4().to_string(),
                    task_ids[3].clone(), // Â∞èÁ∫¢‰π¶Á≤â‰∏ùÂ¢ûÈïø
                    employee_1_id.to_string(),
                    "ÂÆåÊàê‰∫Ü200‰∏™Ë¥¶Âè∑ÁöÑÂÖ≥Ê≥®Âíå‰∫íÂä®ÔºåÊñ∞Â¢ûÁ≤â‰∏ù150‰∫∫",
                    6.0,
                    "2025-10-18",
                ),
                (
                    Uuid::new_v4().to_string(),
                    task_ids[3].clone(),
                    employee_1_id.to_string(),
                    "ÂèëÂ∏É‰∫Ü3ÁØá‰∫íÂä®ÂÜÖÂÆπÔºåÁÇπËµûÊî∂ËóèÂÖ±ËÆ°500Ê¨°",
                    6.0,
                    "2025-10-19",
                ),
                (
                    Uuid::new_v4().to_string(),
                    task_ids[5].clone(), // ‰∫ßÂìÅÁ¨îËÆ∞Âàõ‰Ωú
                    employee_1_id.to_string(),
                    "ÂÆåÊàê‰∫Ü2ÁØá‰∫ßÂìÅÊµãËØÑÁ¨îËÆ∞ÁöÑÊí∞ÂÜôÂíåÂèëÂ∏É",
                    6.0,
                    "2025-10-23",
                ),
                (
                    Uuid::new_v4().to_string(),
                    task_ids[8].clone(), // Â≠¶‰π†Êñ∞ÊäÄÂ∑ß
                    employee_1_id.to_string(),
                    "Â≠¶‰π†‰∫ÜÁü≠ËßÜÈ¢ëÂàõ‰ΩúÊäÄÂ∑ßËØæÁ®ã",
                    3.0,
                    "2025-10-29",
                ),
            ];

            let work_log_count = work_logs.len();
            for (id, task_id, user_id, description, hours, work_date) in work_logs {
                sqlx::query(
                    r#"
                    INSERT INTO work_logs (id, task_id, user_id, hours, notes, logged_at, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                    "#,
                )
                .bind(id)
                .bind(task_id)
                .bind(user_id)
                .bind(hours)
                .bind(description)
                .bind(work_date)
                .execute(&self.pool)
                .await?;
            }

            tracing::info!("‚úÖ ÊµãËØïÂ∑•‰ΩúÊó•ÂøóÂàõÂª∫ÂÆåÊàêÔºåÂÖ± {} Êù°ËÆ∞ÂΩï", work_log_count);
        } else {
            tracing::info!("‚ÑπÔ∏è  ÊµãËØïÈ°πÁõÆÊï∞ÊçÆÂ∑≤Â≠òÂú®ÔºåË∑≥ËøáÂàõÂª∫");
        }

        Ok(())
    }
}
